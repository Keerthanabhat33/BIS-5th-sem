import numpy as np

# --- Define the Rastrigin Function ---
def rastrigin(X):
    A = 10
    return A * len(X) + sum(x**2 - A * np.cos(2 * np.pi * x) for x in X)

# --- Get User Inputs ---
num_particles = int(input("Enter number of particles (e.g. 30): "))
num_dimensions = int(input("Enter number of dimensions (e.g. 2): "))
num_iterations = int(input("Enter number of iterations (e.g. 100): "))
lower_bound = float(input("Enter lower bound (e.g. -5.12): "))
upper_bound = float(input("Enter upper bound (e.g. 5.12): "))
bounds = (lower_bound, upper_bound)

# PSO coefficients (optional: make these user inputs too)
w = 0.5
c1 = 1.5
c2 = 1.5

# --- Define Particle Class ---
class Particle:
    def __init__(self):
        self.position = np.random.uniform(bounds[0], bounds[1], num_dimensions)
        self.velocity = np.random.uniform(-1, 1, num_dimensions)
        self.best_position = np.copy(self.position)
        self.best_score = rastrigin(self.position)

# --- Initialize Swarm ---
swarm = [Particle() for _ in range(num_particles)]
global_best_position = min(swarm, key=lambda p: p.best_score).best_position
global_best_score = rastrigin(global_best_position)

# --- PSO Loop ---
for iteration in range(num_iterations):
    for particle in swarm:
        fitness = rastrigin(particle.position)

        # Update personal best
        if fitness < particle.best_score:
            particle.best_score = fitness
            particle.best_position = particle.position

        # Update global best
        if fitness < global_best_score:
            global_best_score = fitness
            global_best_position = particle.position

    for particle in swarm:
        r1 = np.random.rand(num_dimensions)
        r2 = np.random.rand(num_dimensions)

        cognitive = c1 * r1 * (particle.best_position - particle.position)
        social = c2 * r2 * (global_best_position - particle.position)
        particle.velocity = w * particle.velocity + cognitive + social
        particle.position += particle.velocity

        # Keep position within bounds
        particle.position = np.clip(particle.position, bounds[0], bounds[1])

    print(f"Iteration {iteration + 1}/{num_iterations}, Global Best Score: {global_best_score:.4f}")

# --- Final Output ---
print("\nOptimization Complete")
print("Best position found:", global_best_position)
print("Best score:", global_best_score)
