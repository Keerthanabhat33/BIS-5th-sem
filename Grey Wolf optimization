import numpy as np
import cv2

class GreyWolfOptimizer:
    def __init__(self, obj_func, dim, lb, ub, num_wolves=20, max_iter=100):
        self.obj_func = obj_func  # Objective function to maximize
        self.dim = dim            # Number of thresholds
        self.lb = lb
        self.ub = ub
        self.num_wolves = num_wolves
        self.max_iter = max_iter
        self.positions = np.random.uniform(low=self.lb, high=self.ub, size=(self.num_wolves, self.dim))
        self.alpha_pos = np.zeros(self.dim)
        self.alpha_score = -float('inf')  # Maximize fitness
        self.beta_pos = np.zeros(self.dim)
        self.beta_score = -float('inf')
        self.delta_pos = np.zeros(self.dim)
        self.delta_score = -float('inf')

    def optimize(self):
        for iter in range(self.max_iter):
            for i in range(self.num_wolves):
                # Boundary check
                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)

                fitness = self.obj_func(self.positions[i])

                # Update Alpha, Beta, Delta (maximization)
                if fitness > self.alpha_score:
                    self.alpha_score = fitness
                    self.alpha_pos = self.positions[i].copy()
                elif fitness > self.beta_score:
                    self.beta_score = fitness
                    self.beta_pos = self.positions[i].copy()
                elif fitness > self.delta_score:
                    self.delta_score = fitness
                    self.delta_pos = self.positions[i].copy()

            a = 2 - iter * (2 / self.max_iter)

            for i in range(self.num_wolves):
                for j in range(self.dim):
                    r1, r2 = np.random.rand(), np.random.rand()
                    A1 = 2 * a * r1 - a
                    C1 = 2 * r2
                    D_alpha = abs(C1 * self.alpha_pos[j] - self.positions[i][j])
                    X1 = self.alpha_pos[j] - A1 * D_alpha

                    r1, r2 = np.random.rand(), np.random.rand()
                    A2 = 2 * a * r1 - a
                    C2 = 2 * r2
                    D_beta = abs(C2 * self.beta_pos[j] - self.positions[i][j])
                    X2 = self.beta_pos[j] - A2 * D_beta

                    r1, r2 = np.random.rand(), np.random.rand()
                    A3 = 2 * a * r1 - a
                    C3 = 2 * r2
                    D_delta = abs(C3 * self.delta_pos[j] - self.positions[i][j])
                    X3 = self.delta_pos[j] - A3 * D_delta

                    self.positions[i][j] = (X1 + X2 + X3) / 3

        return np.sort(self.alpha_pos), self.alpha_score

# Otsu's multi-threshold fitness function
def otsu_fitness(thresholds, image):
    thresholds = np.sort(thresholds)
    thresholds = np.concatenate(([0], thresholds, [256]))

    total_pixels = image.size
    total_mean = np.mean(image)
    between_class_variance = 0

    for i in range(len(thresholds) - 1):
        mask = (image >= thresholds[i]) & (image < thresholds[i+1])
        region = image[mask]
        prob = region.size / total_pixels
        if prob == 0:
            continue
        mean_region = np.mean(region)
        between_class_variance += prob * ((mean_region - total_mean) ** 2)

    return between_class_variance

def segment_image(image, thresholds):
    thresholds = np.sort(thresholds)
    thresholds = [0] + list(thresholds) + [256]
    segmented = np.zeros_like(image)

    for i in range(len(thresholds) - 1):
        mask = (image >= thresholds[i]) & (image < thresholds[i+1])
        segmented[mask] = int(255 / (len(thresholds)-1)) * i

    return segmented

if __name__ == "__main__":
    # Load grayscale image
    image = cv2.imread("C:/Users/BMSCE/Pictures/istockphoto-1252455620-612x612.jpg", 0)


    if image is None:
        raise ValueError("Image not found. Please check the file path.")

    # Parameters
    num_thresholds = 3  # Number of thresholds for segmentation
    gwo = GreyWolfOptimizer(
        obj_func=lambda x: otsu_fitness(x, image),
        dim=num_thresholds,
        lb=0,
        ub=255,
        num_wolves=30,
        max_iter=100
    )

    best_thresholds, best_score = gwo.optimize()
    print("Optimal thresholds:", best_thresholds)
    print("Best fitness (between-class variance):", best_score)

    segmented_img = segment_image(image, best_thresholds)

    # Save segmented image
    cv2.imwrite('segmented_image.jpg', segmented_img)
    print("Segmented image saved as 'segmented_image.jpg'")
